{"version":3,"sources":["../src/index.ts","../node_modules/yocto-queue/index.js","../node_modules/p-limit/index.js"],"sourcesContent":["import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig, AxiosAdapter } from 'axios';\nimport pLimit from 'p-limit';\n\nexport interface AxiosParallelLimitOptions {\n    /**\n     * The maximum number of parallel requests.\n     */\n    maxRequests: number;\n    /**\n     * Callback function called when the number of active requests changes.\n     */\n    onActiveCountChange?: (activeCount: number) => void;\n    /**\n     * Callback function called when the number of pending requests changes.\n     */\n    onPendingCountChange?: (pendingCount: number) => void;\n}\n\n/**\n * Limits the number of parallel requests for an Axios instance.\n * @param axiosInstance The Axios instance to apply the limit to.\n * @param options Configuration options.\n */\nexport function axiosParallelLimit(\n    axiosInstance: AxiosInstance,\n    options: AxiosParallelLimitOptions\n): void {\n    const limit = pLimit(options.maxRequests);\n\n    const notify = () => {\n        if (options.onActiveCountChange) {\n            options.onActiveCountChange(limit.activeCount);\n        }\n        if (options.onPendingCountChange) {\n            options.onPendingCountChange(limit.pendingCount);\n        }\n    };\n\n    axiosInstance.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n        const originalAdapter = config.adapter;\n\n        if (!originalAdapter) {\n            return config;\n        }\n\n        config.adapter = async (adapterConfig) => {\n            notify();\n\n            return limit(async () => {\n                notify();\n                try {\n                    if (typeof originalAdapter === 'function') {\n                        return await originalAdapter(adapterConfig);\n                    } else if (Array.isArray(originalAdapter)) {\n                        // Iterate over adapters as Axios does\n                        for (const adapterNameOrFunc of originalAdapter) {\n                            let adapter: AxiosAdapter | undefined;\n\n                            if (typeof adapterNameOrFunc === 'function') {\n                                adapter = adapterNameOrFunc;\n                            } else if (typeof adapterNameOrFunc === 'string') {\n                                try {\n                                    // @ts-ignore - getAdapter is not in all type definitions yet but exists in runtime\n                                    adapter = axios.getAdapter(adapterNameOrFunc);\n                                } catch (err) {\n                                    // Adapter not supported or not found\n                                    continue;\n                                }\n                            }\n\n                            if (adapter) {\n                                try {\n                                    return await adapter(adapterConfig);\n                                } catch (err: any) {\n                                    if (err && (err.code === 'ERR_ADAPTER_NOT_SUPPORTED' || err.code === 'ERR_NOT_SUPPORT')) {\n                                        continue;\n                                    }\n                                    throw err;\n                                }\n                            }\n                        }\n                        throw new Error('No adapter in the array handled the request');\n                    } else if (typeof originalAdapter === 'string') {\n                        try {\n                            // @ts-ignore\n                            const adapter = axios.getAdapter(originalAdapter);\n                            return await adapter(adapterConfig);\n                        } catch (err) {\n                            throw new Error(`String adapter '${originalAdapter}' failed: ${err}`);\n                        }\n                    } else {\n                        // It might be an object that is NOT an array?\n                        // Some custom adapters might be objects with a `call` method?\n                        // Unlikely for standard axios.\n                        throw new Error(`Adapter is not a function or array, it is: ${typeof originalAdapter}`);\n                    }\n                } finally {\n                    // Request finished\n                }\n            }).finally(() => {\n                notify();\n            });\n        };\n\n        return config;\n    });\n}\n","/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\n\t\t// Clean up tail reference when queue becomes empty\n\t\tif (!this.#head) {\n\t\t\tthis.#tail = undefined;\n\t\t}\n\n\t\treturn current.value;\n\t}\n\n\tpeek() {\n\t\tif (!this.#head) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#head.value;\n\n\t\t// TODO: Node.js 18.\n\t\t// return this.#head?.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\t* drain() {\n\t\twhile (this.#head) {\n\t\t\tyield this.dequeue();\n\t\t}\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\t// Process the next queued function if we're under the concurrency limit\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tactiveCount++;\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\t// Execute the function and capture the result promise\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\t// Resolve immediately with the promise (don't wait for completion)\n\t\tresolve(result);\n\n\t\t// Wait for the function to complete (success or failure)\n\t\t// We catch errors here to prevent unhandled rejections,\n\t\t// but the original promise rejection is preserved for the caller\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\t// Decrement active count and process next queued function\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue the internal resolve function instead of the run function\n\t\t// to preserve the asynchronous execution context.\n\t\tnew Promise(internalResolve => { // eslint-disable-line promise/param-names\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_)); // eslint-disable-line promise/prefer-await-to-then\n\n\t\t// Start processing immediately if we haven't reached the concurrency limit\n\t\tif (activeCount < concurrency) {\n\t\t\tresumeNext();\n\t\t}\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t\tmap: {\n\t\t\tasync value(iterable, function_) {\n\t\t\t\tconst promises = Array.from(iterable, (value, index) => this(function_, value, index));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nexport function limitFunction(function_, options) {\n\tconst {concurrency} = options;\n\tconst limit = pLimit(concurrency);\n\n\treturn (...arguments_) => limit(() => function_(...arguments_));\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n"],"mappings":"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","names":[]}